// Generated by CoffeeScript 1.6.2
(function() {
  var Haml, Node, escapeQuotes, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Node = require('./node');

  escapeQuotes = require('../util/text').escapeQuotes;

  module.exports = Haml = (function(_super) {
    __extends(Haml, _super);

    function Haml() {
      _ref = Haml.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Haml.prototype.evaluate = function() {
      var assignment, code, identifier, match, prefix, tokens;

      tokens = this.parseExpression(this.expression);
      if (tokens.doctype) {
        return this.opener = this.markText("" + (escapeQuotes(this.buildDocType(tokens.doctype))));
      } else {
        if (this.isNotSelfClosing(tokens.tag)) {
          prefix = this.buildHtmlTagPrefix(tokens);
          if (tokens.assignment) {
            match = tokens.assignment.match(/^(=|!=|&=|~)\s*(.*)$/);
            identifier = match[1];
            assignment = match[2];
            if (identifier === '~') {
              code = "\#{$fp " + assignment + " }";
            } else if (identifier === '&=' || (identifier === '=' && this.escapeHtml)) {
              if (this.preserve) {
                if (this.cleanValue) {
                  code = "\#{ $p($e($c(" + assignment + "))) }";
                } else {
                  code = "\#{ $p($e(" + assignment + ")) }";
                }
              } else {
                if (this.cleanValue) {
                  code = "\#{ $e($c(" + assignment + ")) }";
                } else {
                  code = "\#{ $e(" + assignment + ") }";
                }
              }
            } else if (identifier === '!=' || (identifier === '=' && !this.escapeHtml)) {
              if (this.preserve) {
                if (this.cleanValue) {
                  code = "\#{ $p($c(" + assignment + ")) }";
                } else {
                  code = "\#{ $p(" + assignment + ") }";
                }
              } else {
                if (this.cleanValue) {
                  code = "\#{ $c(" + assignment + ") }";
                } else {
                  code = "\#{ " + assignment + " }";
                }
              }
            }
            this.opener = this.markText("" + prefix + ">" + code);
            return this.closer = this.markText("</" + tokens.tag + ">");
          } else if (tokens.text) {
            this.opener = this.markText("" + prefix + ">" + tokens.text);
            return this.closer = this.markText("</" + tokens.tag + ">");
          } else {
            this.opener = this.markText(prefix + '>');
            return this.closer = this.markText("</" + tokens.tag + ">");
          }
        } else {
          tokens.tag = tokens.tag.replace(/\/$/, '');
          prefix = this.buildHtmlTagPrefix(tokens);
          return this.opener = this.markText("" + prefix + (this.format === 'xhtml' ? ' /' : '') + ">");
        }
      }
    };

    Haml.prototype.parseExpression = function(exp) {
      var attributes, classes, id, key, tag, value, _ref1, _ref2;

      tag = this.parseTag(exp);
      if (this.preserveTags.indexOf(tag.tag) !== -1) {
        this.preserve = true;
      }
      id = this.interpolateCodeAttribute((_ref1 = tag.ids) != null ? _ref1.pop() : void 0, true);
      classes = tag.classes;
      attributes = {};
      if (tag.attributes) {
        _ref2 = tag.attributes;
        for (key in _ref2) {
          value = _ref2[key];
          if (key === 'id') {
            if (id) {
              id += '_' + this.interpolateCodeAttribute(value, true);
            } else {
              id = this.interpolateCodeAttribute(value, true);
            }
          } else if (key === 'class') {
            classes || (classes = []);
            classes.push(value);
          } else {
            attributes[key] = value;
          }
        }
      }
      return {
        doctype: tag.doctype,
        tag: tag.tag,
        id: id,
        classes: classes,
        text: escapeQuotes(tag.text),
        attributes: attributes,
        assignment: tag.assignment,
        reference: tag.reference
      };
    };

    Haml.prototype.parseTag = function(exp) {
      var assignment, attr, attributes, ch, classes, doctype, end, error, haml, htmlAttributes, id, ids, key, klass, level, pos, reference, rest, rubyAttributes, start, tag, text, val, whitespace, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;

      try {
        doctype = (_ref1 = exp.match(/^(\!{3}.*)/)) != null ? _ref1[1] : void 0;
        if (doctype) {
          return {
            doctype: doctype
          };
        }
        haml = exp.match(/^((?:[#%\.][a-z0-9_:\-]*[\/]?)+)/i)[0];
        rest = exp.substring(haml.length);
        if (rest.match(/^[{([]/)) {
          reference = '';
          htmlAttributes = '';
          rubyAttributes = '';
          _ref2 = ['[', '{', '(', '[', '{', '('];
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            start = _ref2[_i];
            if (start === rest[0]) {
              end = (function() {
                switch (start) {
                  case '{':
                    return '}';
                  case '(':
                    return ')';
                  case '[':
                    return ']';
                }
              })();
              level = 0;
              for (pos = _j = 0, _ref3 = rest.length; 0 <= _ref3 ? _j <= _ref3 : _j >= _ref3; pos = 0 <= _ref3 ? ++_j : --_j) {
                ch = rest[pos];
                if (ch === start) {
                  level += 1;
                }
                if (ch === end) {
                  if (level === 1) {
                    break;
                  } else {
                    level -= 1;
                  }
                }
              }
              switch (start) {
                case '{':
                  rubyAttributes += rest.substring(0, pos + 1);
                  rest = rest.substring(pos + 1);
                  break;
                case '(':
                  htmlAttributes += rest.substring(0, pos + 1);
                  rest = rest.substring(pos + 1);
                  break;
                case '[':
                  reference = rest.substring(1, pos);
                  rest = rest.substring(pos + 1);
              }
            }
          }
          assignment = rest || '';
        } else {
          reference = '';
          htmlAttributes = '';
          rubyAttributes = '';
          assignment = rest;
        }
        attributes = {};
        _ref4 = [this.parseAttributes(htmlAttributes), this.parseAttributes(rubyAttributes)];
        for (_k = 0, _len1 = _ref4.length; _k < _len1; _k++) {
          attr = _ref4[_k];
          for (key in attr) {
            val = attr[key];
            attributes[key] = val;
          }
        }
        if (whitespace = (_ref5 = assignment.match(/^[<>]{0,2}/)) != null ? _ref5[0] : void 0) {
          assignment = assignment.substring(whitespace.length);
        }
        if (assignment[0] === ' ') {
          assignment = assignment.substring(1);
        }
        if (assignment && !assignment.match(/^(=|!=|&=|~)/)) {
          text = assignment.replace(/^ /, '');
          assignment = void 0;
        }
        if (whitespace) {
          if (whitespace.indexOf('>') !== -1) {
            this.wsRemoval.around = true;
          }
          if (whitespace.indexOf('<') !== -1) {
            this.wsRemoval.inside = true;
            this.preserve = true;
          }
        }
        tag = haml.match(/\%([a-z_\-][a-z0-9_:\-]*[\/]?)/i);
        ids = haml.match(/\#([a-z_\-][a-z0-9_\-]*)/gi);
        classes = haml.match(/\.([a-z0-9_\-]*)/gi);
        return {
          tag: tag ? tag[1] : 'div',
          ids: ids ? (function() {
            var _l, _len2, _results;

            _results = [];
            for (_l = 0, _len2 = ids.length; _l < _len2; _l++) {
              id = ids[_l];
              _results.push("'" + (id.substr(1)) + "'");
            }
            return _results;
          })() : void 0,
          classes: classes ? (function() {
            var _l, _len2, _results;

            _results = [];
            for (_l = 0, _len2 = classes.length; _l < _len2; _l++) {
              klass = classes[_l];
              _results.push("'" + (klass.substr(1)) + "'");
            }
            return _results;
          })() : void 0,
          attributes: attributes,
          assignment: assignment,
          reference: reference,
          text: text
        };
      } catch (_error) {
        error = _error;
        throw new Error("Unable to parse tag from " + exp + ": " + error);
      }
    };

    Haml.prototype.parseAttributes = function(exp) {
      var attr, attributes, ch, endPos, hasDataAttribute, inDataAttribute, key, keyValue, keys, level, marker, markers, pairs, pos, quote, quoted, start, startPos, type, value, _i, _j, _k, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5;

      attributes = {};
      if (exp === void 0) {
        return attributes;
      }
      type = exp.substring(0, 1);
      exp = exp.replace(/(=|:|=>)\s*('([^\\']|\\\\|\\')*'|"([^\\"]|\\\\|\\")*")/g, function(match, type, value) {
        return type + (value != null ? value.replace(/(:|=|=>)/g, '\u0090$1') : void 0);
      });
      level = 0;
      start = 0;
      markers = [];
      if (type === '(') {
        startPos = 1;
        endPos = exp.length - 1;
      } else {
        startPos = 0;
        endPos = exp.length;
      }
      for (pos = _i = startPos; startPos <= endPos ? _i < endPos : _i > endPos; pos = startPos <= endPos ? ++_i : --_i) {
        ch = exp[pos];
        if (ch === '(') {
          level += 1;
          if (level === 1) {
            start = pos;
          }
        }
        if (ch === ')') {
          if (level === 1) {
            if (start !== 0 && pos - start !== 1) {
              markers.push({
                start: start,
                end: pos
              });
            }
          } else {
            level -= 1;
          }
        }
      }
      _ref1 = markers.reverse();
      for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
        marker = _ref1[_j];
        exp = exp.substring(0, marker.start) + exp.substring(marker.start, marker.end).replace(/(:|=|=>)/g, '\u0090$1') + exp.substring(marker.end);
      }
      switch (type) {
        case '(':
          keys = /\(\s*([-\w]+[\w:-]*\w?)\s*=|\s+([-\w]+[\w:-]*\w?)\s*=|\(\s*('\w+[\w:-]*\w?')\s*=|\s+('\w+[\w:-]*\w?')\s*=|\(\s*("\w+[\w:-]*\w?")\s*=|\s+("\w+[\w:-]*\w?")\s*=/g;
          break;
        case '{':
          keys = /[{,]\s*(\w+[\w:-]*\w?)\s*:|[{,]\s*('[-\w]+[\w:-]*\w?')\s*:|[{,]\s*("[-\w]+[\w:-]*\w?")\s*:|[{,]\s*:(\w+[\w:-]*\w?)\s*=>|[{,]\s*:?'([-\w]+[\w:-]*\w?)'\s*=>|[{,]\s*:?"([-\w]+[\w:-]*\w?)"\s*=>/g;
      }
      pairs = exp.split(keys).filter(Boolean);
      inDataAttribute = false;
      hasDataAttribute = false;
      while (pairs.length) {
        keyValue = pairs.splice(0, 2);
        if (keyValue.length === 1) {
          attr = keyValue[0].replace(/^[\s({]+|[\s)}]+$/g, '');
          attributes[attr] = 'true';
        } else {
          key = (_ref2 = keyValue[0]) != null ? _ref2.replace(/^\s+|\s+$/g, '').replace(/^:/, '') : void 0;
          if (quoted = key.match(/^("|')(.*)\1$/)) {
            key = quoted[2];
          }
          value = (_ref3 = keyValue[1]) != null ? _ref3.replace(/^\s+|[\s,]+$/g, '').replace(/\u0090/g, '') : void 0;
          if (key === 'data' && !value) {
            inDataAttribute = true;
            hasDataAttribute = true;
          } else if (key && value) {
            if (inDataAttribute) {
              key = this.hyphenateDataAttrs ? "data-" + (key.replace('_', '-')) : "data-" + key;
              if (/}\s*$/.test(value)) {
                inDataAttribute = false;
              }
            }
          }
          switch (type) {
            case '(':
              value = value.replace(/^\s+|[\s)]+$/g, '');
              quote = (_ref4 = /^(['"])/.exec(value)) != null ? _ref4[1] : void 0;
              pos = value.lastIndexOf(quote);
              if (pos > 1) {
                _ref5 = value.substring(pos + 1).split(' ');
                for (_k = 0, _len1 = _ref5.length; _k < _len1; _k++) {
                  attr = _ref5[_k];
                  if (attr) {
                    attributes[attr] = 'true';
                  }
                }
                value = value.substring(0, pos + 1);
              }
              attributes[key] = value;
              break;
            case '{':
              attributes[key] = value.replace(/^\s+|[\s}]+$/g, '');
          }
        }
      }
      if (hasDataAttribute) {
        delete attributes['data'];
      }
      return attributes;
    };

    Haml.prototype.buildHtmlTagPrefix = function(tokens) {
      var classList, classes, hasDynamicClass, key, klass, name, tagParts, value, _i, _len, _ref1;

      tagParts = ["<" + tokens.tag];
      if (tokens.classes) {
        hasDynamicClass = false;
        classList = (function() {
          var _i, _len, _ref1, _results;

          _ref1 = tokens.classes;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            name = _ref1[_i];
            name = this.interpolateCodeAttribute(name, true);
            if (name.indexOf('#{') !== -1) {
              hasDynamicClass = true;
            }
            _results.push(name);
          }
          return _results;
        }).call(this);
        if (hasDynamicClass && classList.length > 1) {
          classes = '#{ [';
          for (_i = 0, _len = classList.length; _i < _len; _i++) {
            klass = classList[_i];
            classes += "" + (this.quoteAndEscapeAttributeValue(klass, true)) + ",";
          }
          classes = classes.substring(0, classes.length - 1) + '].sort().join(\' \').replace(/^\\s+|\\s+$/g, \'\') }';
        } else {
          classes = classList.sort().join(' ');
        }
        tagParts.push("class='" + classes + "'");
      }
      if (tokens.id) {
        tagParts.push("id='" + tokens.id + "'");
      }
      if (tokens.reference) {
        if (tokens.attributes) {
          delete tokens.attributes['class'];
          delete tokens.attributes['id'];
        }
        tagParts.push("\#{$r(" + tokens.reference + ")}");
      }
      if (tokens.attributes) {
        _ref1 = tokens.attributes;
        for (key in _ref1) {
          value = _ref1[key];
          if (value === 'true' || value === 'false') {
            if (value === 'true') {
              if (this.format === 'html5') {
                tagParts.push("" + key);
              } else {
                tagParts.push("" + key + "=" + (this.quoteAndEscapeAttributeValue(key)));
              }
            }
          } else {
            tagParts.push("" + key + "=" + (this.quoteAndEscapeAttributeValue(this.interpolateCodeAttribute(value))));
          }
        }
      }
      return tagParts.join(' ');
    };

    Haml.prototype.interpolateCodeAttribute = function(text, unwrap) {
      var quoted;

      if (unwrap == null) {
        unwrap = false;
      }
      if (!text) {
        return;
      }
      if (!text.match(/^("|').*\1$/)) {
        if (this.escapeAttributes) {
          if (this.cleanValue) {
            text = '#{ $e($c(' + text + ')) }';
          } else {
            text = '#{ $e(' + text + ') }';
          }
        } else {
          if (this.cleanValue) {
            text = '#{ $c(' + text + ') }';
          } else {
            text = '#{ (' + text + ') }';
          }
        }
      }
      if (unwrap) {
        if (quoted = text.match(/^("|')(.*)\1$/)) {
          text = quoted[2];
        }
      }
      return text;
    };

    Haml.prototype.quoteAndEscapeAttributeValue = function(value, code) {
      var escaped, hasDoubleQuotes, hasInterpolation, hasSingleQuotes, quoted, result, token, tokens;

      if (code == null) {
        code = false;
      }
      if (!value) {
        return;
      }
      if (quoted = value.match(/^("|')(.*)\1$/)) {
        value = quoted[2];
      }
      tokens = this.splitInterpolations(value);
      hasSingleQuotes = false;
      hasDoubleQuotes = false;
      hasInterpolation = false;
      tokens = (function() {
        var _i, _len, _results;

        _results = [];
        for (_i = 0, _len = tokens.length; _i < _len; _i++) {
          token = tokens[_i];
          if (token.slice(0, 2) === '#{') {
            if (token.indexOf('$e') === -1 && token.indexOf('$c') === -1) {
              if (this.escapeAttributes) {
                if (this.cleanValue) {
                  token = '#{ $e($c(' + token.slice(2, -1) + ')) }';
                } else {
                  token = '#{ $e(' + token.slice(2, -1) + ') }';
                }
              } else {
                if (this.cleanValue) {
                  token = '#{ $c(' + token.slice(2, -1) + ') }';
                }
              }
            }
            hasInterpolation = true;
          } else {
            if (!hasSingleQuotes) {
              hasSingleQuotes = token.indexOf("'") !== -1;
            }
            if (!hasDoubleQuotes) {
              hasDoubleQuotes = token.indexOf('"') !== -1;
            }
          }
          _results.push(token);
        }
        return _results;
      }).call(this);
      if (code) {
        if (hasInterpolation) {
          result = "\"" + (tokens.join('')) + "\"";
        } else {
          result = "'" + (tokens.join('')) + "'";
        }
      } else {
        if (!hasDoubleQuotes && !hasSingleQuotes) {
          result = "'" + (tokens.join('')) + "'";
        }
        if (hasSingleQuotes && !hasDoubleQuotes) {
          result = "\\\"" + (tokens.join('')) + "\\\"";
        }
        if (hasDoubleQuotes && !hasSingleQuotes) {
          escaped = (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = tokens.length; _i < _len; _i++) {
              token = tokens[_i];
              _results.push(escapeQuotes(token));
            }
            return _results;
          })();
          result = "'" + (escaped.join('')) + "'";
        }
        if (hasSingleQuotes && hasDoubleQuotes) {
          escaped = (function() {
            var _i, _len, _results;

            _results = [];
            for (_i = 0, _len = tokens.length; _i < _len; _i++) {
              token = tokens[_i];
              _results.push(escapeQuotes(token).replace(/'/g, '&#39;'));
            }
            return _results;
          })();
          result = "'" + (escaped.join('')) + "'";
        }
      }
      return result;
    };

    Haml.prototype.splitInterpolations = function(value) {
      var ch, ch2, level, pos, start, tokens, _i, _ref1;

      level = 0;
      start = 0;
      tokens = [];
      for (pos = _i = 0, _ref1 = value.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; pos = 0 <= _ref1 ? ++_i : --_i) {
        ch = value[pos];
        ch2 = value.slice(pos, +(pos + 1) + 1 || 9e9);
        if (ch === '{') {
          level += 1;
        }
        if (ch2 === '#{' && level === 0) {
          tokens.push(value.slice(start, pos));
          start = pos;
        }
        if (ch === '}') {
          level -= 1;
          if (level === 0) {
            tokens.push(value.slice(start, +pos + 1 || 9e9));
            start = pos + 1;
          }
        }
      }
      tokens.push(value.slice(start, value.length));
      return tokens.filter(Boolean);
    };

    Haml.prototype.buildDocType = function(doctype) {
      switch ("" + this.format + " " + doctype) {
        case 'xhtml !!! XML':
          return '<?xml version=\'1.0\' encoding=\'utf-8\' ?>';
        case 'xhtml !!!':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">';
        case 'xhtml !!! 1.1':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">';
        case 'xhtml !!! mobile':
          return '<!DOCTYPE html PUBLIC "-//WAPFORUM//DTD XHTML Mobile 1.2//EN" "http://www.openmobilealliance.org/tech/DTD/xhtml-mobile12.dtd">';
        case 'xhtml !!! basic':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.1//EN" "http://www.w3.org/TR/xhtml-basic/xhtml-basic11.dtd">';
        case 'xhtml !!! frameset':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">';
        case 'xhtml !!! 5':
        case 'html5 !!!':
          return '<!DOCTYPE html>';
        case 'html5 !!! XML':
        case 'html4 !!! XML':
          return '';
        case 'html4 !!!':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">';
        case 'html4 !!! frameset':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">';
        case 'html4 !!! strict':
          return '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">';
      }
    };

    Haml.prototype.isNotSelfClosing = function(tag) {
      return this.selfCloseTags.indexOf(tag) === -1 && !tag.match(/\/$/);
    };

    return Haml;

  })(Node);

}).call(this);
